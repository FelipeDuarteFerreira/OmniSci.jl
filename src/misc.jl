mutable struct MapDConnection
    session::TSessionId
    c::MapDClient
end

#connect function to abstract away needing to build MapDClient
#user passes MapDConnection created from connect instead of individual pieces
function connect(host::String, port::Int, user::String, passwd::String, dbname::String)

    socket = TSocket(host, port)
    Thrift.set_field!(socket, :io, Base.connect(host, port))
    #transport = TBufferedTransport(socket) # https://github.com/tanmaykm/Thrift.jl/issues/12
    proto = TBinaryProtocol(socket)
    c = MapD.MapDClient(proto)

    session = MapD.connect(c, user, passwd, dbname)

    return MapDConnection(session, c)

end

disconnect(conn::MapDConnection) = disconnect(conn.c, conn.session) #consider printing to console that disconnection happened
get_server_status(conn::MapDConnection) = get_server_status(conn.c, conn.session)
get_status(conn::MapDConnection) = get_status(conn.c, conn.session)
get_hardware_info(conn::MapDConnection) = get_hardware_info(conn.c, conn.session)
get_tables(conn::MapDConnection) = get_tables(conn.c, conn.session)
get_physical_tables(conn::MapDConnection) = get_physical_tables(conn.c, conn.session)
get_views(conn::MapDConnection) = get_views(conn.c, conn.session)
get_tables_meta(conn::MapDConnection) = get_tables_meta(conn.c, conn.session)
get_table_details(conn::MapDConnection, table_name::String) = get_table_details(conn.c, conn.session, table_name)
get_internal_table_details(conn::MapDConnection, table_name::String) = get_internal_table_details(conn.c, conn.session, table_name)
get_users(conn::MapDConnection) = get_users(conn.c, conn.session)
get_databases(conn::MapDConnection) = get_databases(conn.c, conn.session)
get_version(conn::MapDConnection) = get_version(conn.c)
start_heap_profile(conn::MapDConnection) = start_heap_profile(conn.c, conn.session)
stop_heap_profile(conn::MapDConnection) = stop_heap_profile(conn.c, conn.session)
get_heap_profile(conn::MapDConnection) = get_heap_profile(conn.c, conn.session)
#get_memory(c::MapDClient, session::TSessionId, memory_level::String)
clear_cpu_memory(conn::MapDConnection) = clear_cpu_memory(conn.c, conn.session)
clear_gpu_memory(conn::MapDConnection) = clear_gpu_memory(conn.c, conn.session)
# set_table_epoch(c::MapDClient, session::TSessionId, db_id::Int32, table_id::Int32, new_epoch::Int32)
# set_table_epoch_by_name(c::MapDClient, session::TSessionId, table_name::String, new_epoch::Int32)
# get_table_epoch(c::MapDClient, session::TSessionId, db_id::Int32, table_id::Int32)
# get_table_epoch_by_name(c::MapDClient, session::TSessionId, table_name::String)
# sql_execute(c::MapDClient, session::TSessionId, query::String, column_format::Bool, nonce::String, first_n::Int32, at_most_n::Int32)
# sql_execute_df(c::MapDClient, session::TSessionId, query::String, device_type::Int32, device_id::Int32, first_n::Int32)
# sql_execute_gdf(c::MapDClient, session::TSessionId, query::String, device_id::Int32, first_n::Int32)
# deallocate_df(c::MapDClient, session::TSessionId, df::TDataFrame, device_type::Int32, device_id::Int32)
interrupt(conn::MapDConnection) = interrupt(conn.c, conn.session)
# sql_validate(c::MapDClient, session::TSessionId, query::String)
# get_completion_hints(c::MapDClient, session::TSessionId, sql::String, cursor::Int32)
# set_execution_mode(c::MapDClient, session::TSessionId, mode::Int32)
# render_vega(c::MapDClient, session::TSessionId, widget_id::Int64, vega_json::String, compression_level::Int32, nonce::String)
# get_result_row_for_pixel(c::MapDClient, session::TSessionId, widget_id::Int64, pixel::TPixel, table_col_names::Dict{String,Vector{String}}, column_format::Bool, pixelRadius::Int32, nonce::String)
# get_frontend_view(c::MapDClient, session::TSessionId, view_name::String)
get_frontend_views(conn::MapDConnection) = get_frontend_views(conn.c, conn.session)
# create_frontend_view(c::MapDClient, session::TSessionId, view_name::String, view_state::String, image_hash::String, view_metadata::String)
# delete_frontend_view(c::MapDClient, session::TSessionId, view_name::String)
# get_dashboard(c::MapDClient, session::TSessionId, dashboard_id::Int32)
get_dashboards(conn::MapDConnection) = get_dashboards(conn.c, conn.session)
# create_dashboard(c::MapDClient, session::TSessionId, dashboard_name::String, dashboard_state::String, image_hash::String, dashboard_metadata::String)
# replace_dashboard(c::MapDClient, session::TSessionId, dashboard_id::Int32, dashboard_name::String, dashboard_owner::String, dashboard_state::String, image_hash::String, dashboard_metadata::String)
# delete_dashboard(c::MapDClient, session::TSessionId, dashboard_id::Int32)
# share_dashboard(c::MapDClient, session::TSessionId, dashboard_id::Int32, groups::Vector{String}, objects::Vector{String}, permissions::TDashboardPermissions)
# unshare_dashboard(c::MapDClient, session::TSessionId, dashboard_id::Int32, groups::Vector{String}, objects::Vector{String}, permissions::TDashboardPermissions)
# get_dashboard_grantees(c::MapDClient, session::TSessionId, dashboard_id::Int32)
# get_link_view(c::MapDClient, session::TSessionId, link::String)
# create_link(c::MapDClient, session::TSessionId, view_state::String, view_metadata::String)
# load_table_binary(c::MapDClient, session::TSessionId, table_name::String, rows::Vector{TRow})
# load_table_binary_columnar(c::MapDClient, session::TSessionId, table_name::String, cols::Vector{TColumn})
# load_table_binary_arrow(c::MapDClient, session::TSessionId, table_name::String, arrow_stream::Vector{UInt8})
# load_table(c::MapDClient, session::TSessionId, table_name::String, rows::Vector{TStringRow})
# detect_column_types(c::MapDClient, session::TSessionId, file_name::String, copy_params::TCopyParams)
# create_table(c::MapDClient, session::TSessionId, table_name::String, row_desc::TRowDescriptor, table_type::Int32)
# import_table(c::MapDClient, session::TSessionId, table_name::String, file_name::String, copy_params::TCopyParams)
# import_geo_table(c::MapDClient, session::TSessionId, table_name::String, file_name::String, copy_params::TCopyParams, row_desc::TRowDescriptor)
# import_table_status(c::MapDClient, session::TSessionId, import_id::String)
# get_first_geo_file_in_archive(c::MapDClient, session::TSessionId, archive_path::String, copy_params::TCopyParams)
# get_all_files_in_archive(c::MapDClient, session::TSessionId, archive_path::String, copy_params::TCopyParams)
# start_query(c::MapDClient, session::TSessionId, query_ra::String, just_explain::Bool)
# execute_first_step(c::MapDClient, pending_query::TPendingQuery)
# broadcast_serialized_rows(c::MapDClient, serialized_rows::String, row_desc::TRowDescriptor, query_id::TQueryId)
# start_render_query(c::MapDClient, session::TSessionId, widget_id::Int64, node_idx::Int16, vega_json::String)
# execute_next_render_step(c::MapDClient, pending_render::TPendingRenderQuery, merged_data::TRenderDataAggMap)
# insert_data(c::MapDClient, session::TSessionId, insert_data::TInsertData)
# checkpoint(c::MapDClient, session::TSessionId, db_id::Int32, table_id::Int32)
# get_table_descriptor(c::MapDClient, session::TSessionId, table_name::String)
# get_row_descriptor(c::MapDClient, session::TSessionId, table_name::String)
get_roles(conn::MapDConnection) = get_dashboards(conn.c, conn.session)
# get_db_objects_for_grantee(c::MapDClient, session::TSessionId, roleName::String)
# get_db_object_privs(c::MapDClient, session::TSessionId, objectName::String, _type::Int32)
# get_all_roles_for_user(c::MapDClient, session::TSessionId, userName::String)
# set_license_key(c::MapDClient, session::TSessionId, key::String, nonce::String)
# get_license_claims(c::MapDClient, session::TSessionId, nonce::String)
